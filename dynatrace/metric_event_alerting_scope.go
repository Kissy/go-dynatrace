// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// MetricEventAlertingScope A single filter for the alerting scope.
//
// This is the base version of the filter, depending on the type,
// the actual JSON may contain additional fields.
// swagger:discriminator MetricEventAlertingScope filterType
type MetricEventAlertingScope interface {
	runtime.Validatable

	// Defines the actual set of fields depending on the value:
	//
	// ENTITY_ID -> EntityIdAlertingScope
	// MANAGEMENT_ZONE -> ManagementZoneAlertingScope
	// TAG -> TagFilterAlertingScope
	// NAME -> NameAlertingScope
	// CUSTOM_DEVICE_GROUP_NAME -> CustomDeviceGroupNameAlertingScope
	// HOST_GROUP_NAME -> HostGroupNameAlertingScope
	// HOST_NAME -> HostNameAlertingScope
	// PROCESS_GROUP_ID -> ProcessGroupIdAlertingScope
	// PROCESS_GROUP_NAME -> ProcessGroupNameAlertingScope
	//
	// Required: true
	// Enum: [ENTITY_ID MANAGEMENT_ZONE TAG NAME CUSTOM_DEVICE_GROUP_NAME HOST_GROUP_NAME HOST_NAME PROCESS_GROUP_ID PROCESS_GROUP_NAME]
	FilterType() string
	SetFilterType(string)
}

type metricEventAlertingScope struct {
	filterTypeField string
}

// FilterType gets the filter type of this polymorphic type
func (m *metricEventAlertingScope) FilterType() string {
	return "MetricEventAlertingScope"
}

// SetFilterType sets the filter type of this polymorphic type
func (m *metricEventAlertingScope) SetFilterType(val string) {

}

// UnmarshalMetricEventAlertingScopeSlice unmarshals polymorphic slices of MetricEventAlertingScope
func UnmarshalMetricEventAlertingScopeSlice(reader io.Reader, consumer runtime.Consumer) ([]MetricEventAlertingScope, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []MetricEventAlertingScope
	for _, element := range elements {
		obj, err := unmarshalMetricEventAlertingScope(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalMetricEventAlertingScope unmarshals polymorphic MetricEventAlertingScope
func UnmarshalMetricEventAlertingScope(reader io.Reader, consumer runtime.Consumer) (MetricEventAlertingScope, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalMetricEventAlertingScope(data, consumer)
}

func unmarshalMetricEventAlertingScope(data []byte, consumer runtime.Consumer) (MetricEventAlertingScope, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the filterType property.
	var getType struct {
		FilterType string `json:"filterType"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("filterType", "body", getType.FilterType); err != nil {
		return nil, err
	}

	// The value of filterType is used to determine which type to create and unmarshal the data into
	switch getType.FilterType {
	case "CustomDeviceGroupNameAlertingScope":
		var result CustomDeviceGroupNameAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "EntityIdAlertingScope":
		var result EntityIDAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "HostGroupNameAlertingScope":
		var result HostGroupNameAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "HostNameAlertingScope":
		var result HostNameAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ManagementZoneAlertingScope":
		var result ManagementZoneAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "MetricEventAlertingScope":
		var result metricEventAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "NameAlertingScope":
		var result NameAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ProcessGroupIdAlertingScope":
		var result ProcessGroupIDAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ProcessGroupNameAlertingScope":
		var result ProcessGroupNameAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TagFilterAlertingScope":
		var result TagFilterAlertingScope
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid filterType value: %q", getType.FilterType)

}

// Validate validates this metric event alerting scope
func (m *metricEventAlertingScope) Validate(formats strfmt.Registry) error {
	return nil
}
