// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// ComparisonBasic Defines how the matching is actually performed: what and how are we comparing.
//
// The actual field set and the list of possible values of the **operator** field depend on the **type** of the comparison.
//
// Find the list of actual models in the description of the **type** field and check the description of the model you need.
// swagger:discriminator ComparisonBasic type
type ComparisonBasic interface {
	runtime.Validatable

	// Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**.
	// Required: true
	Negate() *bool
	SetNegate(*bool)

	// Operator of the comparision.
	//
	// You can reverse it by setting **negate** to `true`.
	// Required: true
	Operator() Enum
	SetOperator(Enum)

	// Defines the actual set of fields depending on the value:
	//
	// STRING -> StringComparison
	// INDEXED_NAME -> IndexedNameComparison
	// INDEXED_STRING -> IndexedStringComparison
	// INTEGER -> IntegerComparison
	// SERVICE_TYPE -> ServiceTypeComparison
	// PAAS_TYPE -> PaasTypeComparison
	// CLOUD_TYPE -> CloudTypeComparison
	// AZURE_SKU -> AzureSkuComparision
	// AZURE_COMPUTE_MODE -> AzureComputeModeComparison
	// ENTITY_ID -> EntityIdComparison
	// SIMPLE_TECH -> SimpleTechComparison
	// SIMPLE_HOST_TECH -> SimpleHostTechComparison
	// SERVICE_TOPOLOGY -> ServiceTopologyComparison
	// DATABASE_TOPOLOGY -> DatabaseTopologyComparison
	// OS_TYPE -> OsTypeComparison
	// HYPERVISOR_TYPE -> HypervisorTypeComparision
	// IP_ADDRESS -> IpAddressComparison
	// OS_ARCHITECTURE -> OsArchitectureComparison
	// BITNESS -> BitnessComparision
	// APPLICATION_TYPE -> ApplicationTypeComparison
	// MOBILE_PLATFORM -> MobilePlatformComparison
	// CUSTOM_APPLICATION_TYPE -> CustomApplicationTypeComparison
	// DCRUM_DECODER_TYPE -> DcrumDecoderComparison
	// SYNTHETIC_ENGINE_TYPE -> SyntheticEngineTypeComparison
	// TAG -> TagComparison
	// INDEXED_TAG -> IndexedTagComparison
	//
	// Required: true
	// Enum: [STRING INDEXED_NAME INDEXED_STRING INTEGER SERVICE_TYPE PAAS_TYPE CLOUD_TYPE AZURE_SKU AZURE_COMPUTE_MODE ENTITY_ID SIMPLE_TECH SIMPLE_HOST_TECH SERVICE_TOPOLOGY DATABASE_TOPOLOGY OS_TYPE HYPERVISOR_TYPE IP_ADDRESS OS_ARCHITECTURE BITNESS APPLICATION_TYPE MOBILE_PLATFORM CUSTOM_APPLICATION_TYPE DCRUM_DECODER_TYPE SYNTHETIC_ENGINE_TYPE TAG INDEXED_TAG]
	Type() string
	SetType(string)

	// The value to compare to.
	Value() interface{}
	SetValue(interface{})
}

type comparisonBasic struct {
	negateField *bool

	operatorField Enum

	typeField string

	valueField interface{}
}

// Negate gets the negate of this polymorphic type
func (m *comparisonBasic) Negate() *bool {
	return m.negateField
}

// SetNegate sets the negate of this polymorphic type
func (m *comparisonBasic) SetNegate(val *bool) {
	m.negateField = val
}

// Operator gets the operator of this polymorphic type
func (m *comparisonBasic) Operator() Enum {
	return m.operatorField
}

// SetOperator sets the operator of this polymorphic type
func (m *comparisonBasic) SetOperator(val Enum) {
	m.operatorField = val
}

// Type gets the type of this polymorphic type
func (m *comparisonBasic) Type() string {
	return "ComparisonBasic"
}

// SetType sets the type of this polymorphic type
func (m *comparisonBasic) SetType(val string) {

}

// Value gets the value of this polymorphic type
func (m *comparisonBasic) Value() interface{} {
	return m.valueField
}

// SetValue sets the value of this polymorphic type
func (m *comparisonBasic) SetValue(val interface{}) {
	m.valueField = val
}

// UnmarshalComparisonBasicSlice unmarshals polymorphic slices of ComparisonBasic
func UnmarshalComparisonBasicSlice(reader io.Reader, consumer runtime.Consumer) ([]ComparisonBasic, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []ComparisonBasic
	for _, element := range elements {
		obj, err := unmarshalComparisonBasic(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalComparisonBasic unmarshals polymorphic ComparisonBasic
func UnmarshalComparisonBasic(reader io.Reader, consumer runtime.Consumer) (ComparisonBasic, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalComparisonBasic(data, consumer)
}

func unmarshalComparisonBasic(data []byte, consumer runtime.Consumer) (ComparisonBasic, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the type property.
	var getType struct {
		Type string `json:"type"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("type", "body", getType.Type); err != nil {
		return nil, err
	}

	// The value of type is used to determine which type to create and unmarshal the data into
	switch getType.Type {
	case "ApplicationTypeComparison":
		var result ApplicationTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "AzureComputeModeComparison":
		var result AzureComputeModeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "AzureSkuComparision":
		var result AzureSkuComparision
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "BitnessComparision":
		var result BitnessComparision
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "CloudTypeComparison":
		var result CloudTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ComparisonBasic":
		var result comparisonBasic
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "CustomApplicationTypeComparison":
		var result CustomApplicationTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "DatabaseTopologyComparison":
		var result DatabaseTopologyComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "DcrumDecoderComparison":
		var result DcrumDecoderComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "EntityIdComparison":
		var result EntityIDComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "HypervisorTypeComparision":
		var result HypervisorTypeComparision
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "IndexedNameComparison":
		var result IndexedNameComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "IndexedStringComparison":
		var result IndexedStringComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "IndexedTagComparison":
		var result IndexedTagComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "IntegerComparison":
		var result IntegerComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "IpAddressComparison":
		var result IPAddressComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "MobilePlatformComparison":
		var result MobilePlatformComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "OsArchitectureComparison":
		var result OsArchitectureComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "OsTypeComparison":
		var result OsTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "PaasTypeComparison":
		var result PaasTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ServiceTopologyComparison":
		var result ServiceTopologyComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ServiceTypeComparison":
		var result ServiceTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "SimpleHostTechComparison":
		var result SimpleHostTechComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "SimpleTechComparison":
		var result SimpleTechComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "StringComparison":
		var result StringComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "SyntheticEngineTypeComparison":
		var result SyntheticEngineTypeComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TagComparison":
		var result TagComparison
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid type value: %q", getType.Type)

}

// Validate validates this comparison basic
func (m *comparisonBasic) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNegate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *comparisonBasic) validateNegate(formats strfmt.Registry) error {

	if err := validate.Required("negate", "body", m.Negate()); err != nil {
		return err
	}

	return nil
}

func (m *comparisonBasic) validateOperator(formats strfmt.Registry) error {

	if err := validate.Required("operator", "body", m.Operator()); err != nil {
		return err
	}

	return nil
}

var comparisonBasicTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STRING","INDEXED_NAME","INDEXED_STRING","INTEGER","SERVICE_TYPE","PAAS_TYPE","CLOUD_TYPE","AZURE_SKU","AZURE_COMPUTE_MODE","ENTITY_ID","SIMPLE_TECH","SIMPLE_HOST_TECH","SERVICE_TOPOLOGY","DATABASE_TOPOLOGY","OS_TYPE","HYPERVISOR_TYPE","IP_ADDRESS","OS_ARCHITECTURE","BITNESS","APPLICATION_TYPE","MOBILE_PLATFORM","CUSTOM_APPLICATION_TYPE","DCRUM_DECODER_TYPE","SYNTHETIC_ENGINE_TYPE","TAG","INDEXED_TAG"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		comparisonBasicTypeTypePropEnum = append(comparisonBasicTypeTypePropEnum, v)
	}
}

const (

	// ComparisonBasicTypeSTRING captures enum value "STRING"
	ComparisonBasicTypeSTRING string = "STRING"

	// ComparisonBasicTypeINDEXEDNAME captures enum value "INDEXED_NAME"
	ComparisonBasicTypeINDEXEDNAME string = "INDEXED_NAME"

	// ComparisonBasicTypeINDEXEDSTRING captures enum value "INDEXED_STRING"
	ComparisonBasicTypeINDEXEDSTRING string = "INDEXED_STRING"

	// ComparisonBasicTypeINTEGER captures enum value "INTEGER"
	ComparisonBasicTypeINTEGER string = "INTEGER"

	// ComparisonBasicTypeSERVICETYPE captures enum value "SERVICE_TYPE"
	ComparisonBasicTypeSERVICETYPE string = "SERVICE_TYPE"

	// ComparisonBasicTypePAASTYPE captures enum value "PAAS_TYPE"
	ComparisonBasicTypePAASTYPE string = "PAAS_TYPE"

	// ComparisonBasicTypeCLOUDTYPE captures enum value "CLOUD_TYPE"
	ComparisonBasicTypeCLOUDTYPE string = "CLOUD_TYPE"

	// ComparisonBasicTypeAZURESKU captures enum value "AZURE_SKU"
	ComparisonBasicTypeAZURESKU string = "AZURE_SKU"

	// ComparisonBasicTypeAZURECOMPUTEMODE captures enum value "AZURE_COMPUTE_MODE"
	ComparisonBasicTypeAZURECOMPUTEMODE string = "AZURE_COMPUTE_MODE"

	// ComparisonBasicTypeENTITYID captures enum value "ENTITY_ID"
	ComparisonBasicTypeENTITYID string = "ENTITY_ID"

	// ComparisonBasicTypeSIMPLETECH captures enum value "SIMPLE_TECH"
	ComparisonBasicTypeSIMPLETECH string = "SIMPLE_TECH"

	// ComparisonBasicTypeSIMPLEHOSTTECH captures enum value "SIMPLE_HOST_TECH"
	ComparisonBasicTypeSIMPLEHOSTTECH string = "SIMPLE_HOST_TECH"

	// ComparisonBasicTypeSERVICETOPOLOGY captures enum value "SERVICE_TOPOLOGY"
	ComparisonBasicTypeSERVICETOPOLOGY string = "SERVICE_TOPOLOGY"

	// ComparisonBasicTypeDATABASETOPOLOGY captures enum value "DATABASE_TOPOLOGY"
	ComparisonBasicTypeDATABASETOPOLOGY string = "DATABASE_TOPOLOGY"

	// ComparisonBasicTypeOSTYPE captures enum value "OS_TYPE"
	ComparisonBasicTypeOSTYPE string = "OS_TYPE"

	// ComparisonBasicTypeHYPERVISORTYPE captures enum value "HYPERVISOR_TYPE"
	ComparisonBasicTypeHYPERVISORTYPE string = "HYPERVISOR_TYPE"

	// ComparisonBasicTypeIPADDRESS captures enum value "IP_ADDRESS"
	ComparisonBasicTypeIPADDRESS string = "IP_ADDRESS"

	// ComparisonBasicTypeOSARCHITECTURE captures enum value "OS_ARCHITECTURE"
	ComparisonBasicTypeOSARCHITECTURE string = "OS_ARCHITECTURE"

	// ComparisonBasicTypeBITNESS captures enum value "BITNESS"
	ComparisonBasicTypeBITNESS string = "BITNESS"

	// ComparisonBasicTypeAPPLICATIONTYPE captures enum value "APPLICATION_TYPE"
	ComparisonBasicTypeAPPLICATIONTYPE string = "APPLICATION_TYPE"

	// ComparisonBasicTypeMOBILEPLATFORM captures enum value "MOBILE_PLATFORM"
	ComparisonBasicTypeMOBILEPLATFORM string = "MOBILE_PLATFORM"

	// ComparisonBasicTypeCUSTOMAPPLICATIONTYPE captures enum value "CUSTOM_APPLICATION_TYPE"
	ComparisonBasicTypeCUSTOMAPPLICATIONTYPE string = "CUSTOM_APPLICATION_TYPE"

	// ComparisonBasicTypeDCRUMDECODERTYPE captures enum value "DCRUM_DECODER_TYPE"
	ComparisonBasicTypeDCRUMDECODERTYPE string = "DCRUM_DECODER_TYPE"

	// ComparisonBasicTypeSYNTHETICENGINETYPE captures enum value "SYNTHETIC_ENGINE_TYPE"
	ComparisonBasicTypeSYNTHETICENGINETYPE string = "SYNTHETIC_ENGINE_TYPE"

	// ComparisonBasicTypeTAG captures enum value "TAG"
	ComparisonBasicTypeTAG string = "TAG"

	// ComparisonBasicTypeINDEXEDTAG captures enum value "INDEXED_TAG"
	ComparisonBasicTypeINDEXEDTAG string = "INDEXED_TAG"
)

// prop value enum
func (m *comparisonBasic) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, comparisonBasicTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}
