// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LogMetricConfig Custom log metric definition.
// swagger:model LogMetricConfig
type LogMetricConfig struct {

	// The metric is enabled (`true`) or disabled (`false`).
	Active bool `json:"active,omitempty"`

	columnDefiningValueField ColumnDefinition

	// The name of the metric, displayed in the UI.
	// Required: true
	// Min Length: 1
	DisplayName *string `json:"displayName"`

	// A list of filters to define the logs to look into.
	//
	//  If several filters are specified, the OR logic applies.
	// Required: true
	// Min Items: 1
	LogSourceFilters []*LogSourceFilter `json:"logSourceFilters"`

	// The unique key of the metric.
	//
	// The key must have the `calc:log.` prefix.
	// Required: true
	// Min Length: 1
	MetricKey *string `json:"metricKey"`

	// The type of the metric data points calculation. For now the only allowed value is `OCCURRENCES`.
	// Required: true
	// Enum: [FP_COLUMN_AVG FP_COLUMN_COUNT FP_COLUMN_MAX FP_COLUMN_MIN FP_COLUMN_SUM FP_COLUMN_TOP_X_AVG FP_COLUMN_TOP_X_COUNT FP_COLUMN_TOP_X_MAX FP_COLUMN_TOP_X_MIN FP_COLUMN_TOP_X_SUM INT_COLUMN_AVG INT_COLUMN_COUNT INT_COLUMN_MAX INT_COLUMN_MIN INT_COLUMN_SUM INT_COLUMN_TOP_X_AVG INT_COLUMN_TOP_X_COUNT INT_COLUMN_TOP_X_MAX INT_COLUMN_TOP_X_MIN INT_COLUMN_TOP_X_SUM OCCURRENCES]
	MetricValueType *string `json:"metricValueType"`

	// The pattern to look for in logs.
	//
	//  Use the [Dynatrace search query language](https://www.dynatrace.com/support/help/shortlink/log-viewer#search-for-text-patterns-in-log-files) to specify it. Quotes must be escaped.
	//
	//  To return all results, leave the field blank.
	// Required: true
	SearchString *string `json:"searchString"`

	// The unit of the metric.
	// Required: true
	// Enum: [BIT BIT_PER_HOUR BIT_PER_MINUTE BIT_PER_SECOND BYTE BYTE_PER_HOUR BYTE_PER_MINUTE BYTE_PER_SECOND CORES COUNT GIBI_BYTE GIGA_BYTE HOUR KIBI_BYTE KIBI_BYTE_PER_HOUR KIBI_BYTE_PER_MINUTE KIBI_BYTE_PER_SECOND KILO_BYTE KILO_BYTE_PER_HOUR KILO_BYTE_PER_MINUTE KILO_BYTE_PER_SECOND MEBI_BYTE MEBI_BYTE_PER_HOUR MEBI_BYTE_PER_MINUTE MEBI_BYTE_PER_SECOND MEGA_BYTE MEGA_BYTE_PER_HOUR MEGA_BYTE_PER_MINUTE MEGA_BYTE_PER_SECOND MICRO_SECOND MILLI_CORES MILLI_SECOND MILLI_SECOND_PER_MINUTE MINUTE NANO_SECOND NANO_SECOND_PER_MINUTE NOT_APPLICABLE PERCENT PER_HOUR PER_MINUTE PER_SECOND PROMILLE RATIO SECOND STATE UNSPECIFIED]
	Unit *string `json:"unit"`

	// The display name of the unit.
	//
	//  Only applicable if the **unit** is set to `UNSPECIFIED`.
	UnitDisplayName string `json:"unitDisplayName,omitempty"`
}

// ColumnDefiningValue gets the column defining value of this base type
func (m *LogMetricConfig) ColumnDefiningValue() ColumnDefinition {
	return m.columnDefiningValueField
}

// SetColumnDefiningValue sets the column defining value of this base type
func (m *LogMetricConfig) SetColumnDefiningValue(val ColumnDefinition) {
	m.columnDefiningValueField = val
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *LogMetricConfig) UnmarshalJSON(raw []byte) error {
	var data struct {
		Active bool `json:"active,omitempty"`

		ColumnDefiningValue json.RawMessage `json:"columnDefiningValue,omitempty"`

		DisplayName *string `json:"displayName"`

		LogSourceFilters []*LogSourceFilter `json:"logSourceFilters"`

		MetricKey *string `json:"metricKey"`

		MetricValueType *string `json:"metricValueType"`

		SearchString *string `json:"searchString"`

		Unit *string `json:"unit"`

		UnitDisplayName string `json:"unitDisplayName,omitempty"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var propColumnDefiningValue ColumnDefinition
	if string(data.ColumnDefiningValue) != "null" {
		columnDefiningValue, err := UnmarshalColumnDefinition(bytes.NewBuffer(data.ColumnDefiningValue), runtime.JSONConsumer())
		if err != nil && err != io.EOF {
			return err
		}
		propColumnDefiningValue = columnDefiningValue
	}

	var result LogMetricConfig

	// active
	result.Active = data.Active

	// columnDefiningValue
	result.columnDefiningValueField = propColumnDefiningValue

	// displayName
	result.DisplayName = data.DisplayName

	// logSourceFilters
	result.LogSourceFilters = data.LogSourceFilters

	// metricKey
	result.MetricKey = data.MetricKey

	// metricValueType
	result.MetricValueType = data.MetricValueType

	// searchString
	result.SearchString = data.SearchString

	// unit
	result.Unit = data.Unit

	// unitDisplayName
	result.UnitDisplayName = data.UnitDisplayName

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m LogMetricConfig) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {
		Active bool `json:"active,omitempty"`

		DisplayName *string `json:"displayName"`

		LogSourceFilters []*LogSourceFilter `json:"logSourceFilters"`

		MetricKey *string `json:"metricKey"`

		MetricValueType *string `json:"metricValueType"`

		SearchString *string `json:"searchString"`

		Unit *string `json:"unit"`

		UnitDisplayName string `json:"unitDisplayName,omitempty"`
	}{

		Active: m.Active,

		DisplayName: m.DisplayName,

		LogSourceFilters: m.LogSourceFilters,

		MetricKey: m.MetricKey,

		MetricValueType: m.MetricValueType,

		SearchString: m.SearchString,

		Unit: m.Unit,

		UnitDisplayName: m.UnitDisplayName,
	},
	)
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		ColumnDefiningValue ColumnDefinition `json:"columnDefiningValue,omitempty"`
	}{

		ColumnDefiningValue: m.columnDefiningValueField,
	},
	)
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this log metric config
func (m *LogMetricConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateColumnDefiningValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogSourceFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetricKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetricValueType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchString(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LogMetricConfig) validateColumnDefiningValue(formats strfmt.Registry) error {

	if swag.IsZero(m.ColumnDefiningValue()) { // not required
		return nil
	}

	if err := m.ColumnDefiningValue().Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("columnDefiningValue")
		}
		return err
	}

	return nil
}

func (m *LogMetricConfig) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("displayName", "body", m.DisplayName); err != nil {
		return err
	}

	if err := validate.MinLength("displayName", "body", string(*m.DisplayName), 1); err != nil {
		return err
	}

	return nil
}

func (m *LogMetricConfig) validateLogSourceFilters(formats strfmt.Registry) error {

	if err := validate.Required("logSourceFilters", "body", m.LogSourceFilters); err != nil {
		return err
	}

	iLogSourceFiltersSize := int64(len(m.LogSourceFilters))

	if err := validate.MinItems("logSourceFilters", "body", iLogSourceFiltersSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.LogSourceFilters); i++ {
		if swag.IsZero(m.LogSourceFilters[i]) { // not required
			continue
		}

		if m.LogSourceFilters[i] != nil {
			if err := m.LogSourceFilters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("logSourceFilters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LogMetricConfig) validateMetricKey(formats strfmt.Registry) error {

	if err := validate.Required("metricKey", "body", m.MetricKey); err != nil {
		return err
	}

	if err := validate.MinLength("metricKey", "body", string(*m.MetricKey), 1); err != nil {
		return err
	}

	return nil
}

var logMetricConfigTypeMetricValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FP_COLUMN_AVG","FP_COLUMN_COUNT","FP_COLUMN_MAX","FP_COLUMN_MIN","FP_COLUMN_SUM","FP_COLUMN_TOP_X_AVG","FP_COLUMN_TOP_X_COUNT","FP_COLUMN_TOP_X_MAX","FP_COLUMN_TOP_X_MIN","FP_COLUMN_TOP_X_SUM","INT_COLUMN_AVG","INT_COLUMN_COUNT","INT_COLUMN_MAX","INT_COLUMN_MIN","INT_COLUMN_SUM","INT_COLUMN_TOP_X_AVG","INT_COLUMN_TOP_X_COUNT","INT_COLUMN_TOP_X_MAX","INT_COLUMN_TOP_X_MIN","INT_COLUMN_TOP_X_SUM","OCCURRENCES"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		logMetricConfigTypeMetricValueTypePropEnum = append(logMetricConfigTypeMetricValueTypePropEnum, v)
	}
}

const (

	// LogMetricConfigMetricValueTypeFPCOLUMNAVG captures enum value "FP_COLUMN_AVG"
	LogMetricConfigMetricValueTypeFPCOLUMNAVG string = "FP_COLUMN_AVG"

	// LogMetricConfigMetricValueTypeFPCOLUMNCOUNT captures enum value "FP_COLUMN_COUNT"
	LogMetricConfigMetricValueTypeFPCOLUMNCOUNT string = "FP_COLUMN_COUNT"

	// LogMetricConfigMetricValueTypeFPCOLUMNMAX captures enum value "FP_COLUMN_MAX"
	LogMetricConfigMetricValueTypeFPCOLUMNMAX string = "FP_COLUMN_MAX"

	// LogMetricConfigMetricValueTypeFPCOLUMNMIN captures enum value "FP_COLUMN_MIN"
	LogMetricConfigMetricValueTypeFPCOLUMNMIN string = "FP_COLUMN_MIN"

	// LogMetricConfigMetricValueTypeFPCOLUMNSUM captures enum value "FP_COLUMN_SUM"
	LogMetricConfigMetricValueTypeFPCOLUMNSUM string = "FP_COLUMN_SUM"

	// LogMetricConfigMetricValueTypeFPCOLUMNTOPXAVG captures enum value "FP_COLUMN_TOP_X_AVG"
	LogMetricConfigMetricValueTypeFPCOLUMNTOPXAVG string = "FP_COLUMN_TOP_X_AVG"

	// LogMetricConfigMetricValueTypeFPCOLUMNTOPXCOUNT captures enum value "FP_COLUMN_TOP_X_COUNT"
	LogMetricConfigMetricValueTypeFPCOLUMNTOPXCOUNT string = "FP_COLUMN_TOP_X_COUNT"

	// LogMetricConfigMetricValueTypeFPCOLUMNTOPXMAX captures enum value "FP_COLUMN_TOP_X_MAX"
	LogMetricConfigMetricValueTypeFPCOLUMNTOPXMAX string = "FP_COLUMN_TOP_X_MAX"

	// LogMetricConfigMetricValueTypeFPCOLUMNTOPXMIN captures enum value "FP_COLUMN_TOP_X_MIN"
	LogMetricConfigMetricValueTypeFPCOLUMNTOPXMIN string = "FP_COLUMN_TOP_X_MIN"

	// LogMetricConfigMetricValueTypeFPCOLUMNTOPXSUM captures enum value "FP_COLUMN_TOP_X_SUM"
	LogMetricConfigMetricValueTypeFPCOLUMNTOPXSUM string = "FP_COLUMN_TOP_X_SUM"

	// LogMetricConfigMetricValueTypeINTCOLUMNAVG captures enum value "INT_COLUMN_AVG"
	LogMetricConfigMetricValueTypeINTCOLUMNAVG string = "INT_COLUMN_AVG"

	// LogMetricConfigMetricValueTypeINTCOLUMNCOUNT captures enum value "INT_COLUMN_COUNT"
	LogMetricConfigMetricValueTypeINTCOLUMNCOUNT string = "INT_COLUMN_COUNT"

	// LogMetricConfigMetricValueTypeINTCOLUMNMAX captures enum value "INT_COLUMN_MAX"
	LogMetricConfigMetricValueTypeINTCOLUMNMAX string = "INT_COLUMN_MAX"

	// LogMetricConfigMetricValueTypeINTCOLUMNMIN captures enum value "INT_COLUMN_MIN"
	LogMetricConfigMetricValueTypeINTCOLUMNMIN string = "INT_COLUMN_MIN"

	// LogMetricConfigMetricValueTypeINTCOLUMNSUM captures enum value "INT_COLUMN_SUM"
	LogMetricConfigMetricValueTypeINTCOLUMNSUM string = "INT_COLUMN_SUM"

	// LogMetricConfigMetricValueTypeINTCOLUMNTOPXAVG captures enum value "INT_COLUMN_TOP_X_AVG"
	LogMetricConfigMetricValueTypeINTCOLUMNTOPXAVG string = "INT_COLUMN_TOP_X_AVG"

	// LogMetricConfigMetricValueTypeINTCOLUMNTOPXCOUNT captures enum value "INT_COLUMN_TOP_X_COUNT"
	LogMetricConfigMetricValueTypeINTCOLUMNTOPXCOUNT string = "INT_COLUMN_TOP_X_COUNT"

	// LogMetricConfigMetricValueTypeINTCOLUMNTOPXMAX captures enum value "INT_COLUMN_TOP_X_MAX"
	LogMetricConfigMetricValueTypeINTCOLUMNTOPXMAX string = "INT_COLUMN_TOP_X_MAX"

	// LogMetricConfigMetricValueTypeINTCOLUMNTOPXMIN captures enum value "INT_COLUMN_TOP_X_MIN"
	LogMetricConfigMetricValueTypeINTCOLUMNTOPXMIN string = "INT_COLUMN_TOP_X_MIN"

	// LogMetricConfigMetricValueTypeINTCOLUMNTOPXSUM captures enum value "INT_COLUMN_TOP_X_SUM"
	LogMetricConfigMetricValueTypeINTCOLUMNTOPXSUM string = "INT_COLUMN_TOP_X_SUM"

	// LogMetricConfigMetricValueTypeOCCURRENCES captures enum value "OCCURRENCES"
	LogMetricConfigMetricValueTypeOCCURRENCES string = "OCCURRENCES"
)

// prop value enum
func (m *LogMetricConfig) validateMetricValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, logMetricConfigTypeMetricValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LogMetricConfig) validateMetricValueType(formats strfmt.Registry) error {

	if err := validate.Required("metricValueType", "body", m.MetricValueType); err != nil {
		return err
	}

	// value enum
	if err := m.validateMetricValueTypeEnum("metricValueType", "body", *m.MetricValueType); err != nil {
		return err
	}

	return nil
}

func (m *LogMetricConfig) validateSearchString(formats strfmt.Registry) error {

	if err := validate.Required("searchString", "body", m.SearchString); err != nil {
		return err
	}

	return nil
}

var logMetricConfigTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIT","BIT_PER_HOUR","BIT_PER_MINUTE","BIT_PER_SECOND","BYTE","BYTE_PER_HOUR","BYTE_PER_MINUTE","BYTE_PER_SECOND","CORES","COUNT","GIBI_BYTE","GIGA_BYTE","HOUR","KIBI_BYTE","KIBI_BYTE_PER_HOUR","KIBI_BYTE_PER_MINUTE","KIBI_BYTE_PER_SECOND","KILO_BYTE","KILO_BYTE_PER_HOUR","KILO_BYTE_PER_MINUTE","KILO_BYTE_PER_SECOND","MEBI_BYTE","MEBI_BYTE_PER_HOUR","MEBI_BYTE_PER_MINUTE","MEBI_BYTE_PER_SECOND","MEGA_BYTE","MEGA_BYTE_PER_HOUR","MEGA_BYTE_PER_MINUTE","MEGA_BYTE_PER_SECOND","MICRO_SECOND","MILLI_CORES","MILLI_SECOND","MILLI_SECOND_PER_MINUTE","MINUTE","NANO_SECOND","NANO_SECOND_PER_MINUTE","NOT_APPLICABLE","PERCENT","PER_HOUR","PER_MINUTE","PER_SECOND","PROMILLE","RATIO","SECOND","STATE","UNSPECIFIED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		logMetricConfigTypeUnitPropEnum = append(logMetricConfigTypeUnitPropEnum, v)
	}
}

const (

	// LogMetricConfigUnitBIT captures enum value "BIT"
	LogMetricConfigUnitBIT string = "BIT"

	// LogMetricConfigUnitBITPERHOUR captures enum value "BIT_PER_HOUR"
	LogMetricConfigUnitBITPERHOUR string = "BIT_PER_HOUR"

	// LogMetricConfigUnitBITPERMINUTE captures enum value "BIT_PER_MINUTE"
	LogMetricConfigUnitBITPERMINUTE string = "BIT_PER_MINUTE"

	// LogMetricConfigUnitBITPERSECOND captures enum value "BIT_PER_SECOND"
	LogMetricConfigUnitBITPERSECOND string = "BIT_PER_SECOND"

	// LogMetricConfigUnitBYTE captures enum value "BYTE"
	LogMetricConfigUnitBYTE string = "BYTE"

	// LogMetricConfigUnitBYTEPERHOUR captures enum value "BYTE_PER_HOUR"
	LogMetricConfigUnitBYTEPERHOUR string = "BYTE_PER_HOUR"

	// LogMetricConfigUnitBYTEPERMINUTE captures enum value "BYTE_PER_MINUTE"
	LogMetricConfigUnitBYTEPERMINUTE string = "BYTE_PER_MINUTE"

	// LogMetricConfigUnitBYTEPERSECOND captures enum value "BYTE_PER_SECOND"
	LogMetricConfigUnitBYTEPERSECOND string = "BYTE_PER_SECOND"

	// LogMetricConfigUnitCORES captures enum value "CORES"
	LogMetricConfigUnitCORES string = "CORES"

	// LogMetricConfigUnitCOUNT captures enum value "COUNT"
	LogMetricConfigUnitCOUNT string = "COUNT"

	// LogMetricConfigUnitGIBIBYTE captures enum value "GIBI_BYTE"
	LogMetricConfigUnitGIBIBYTE string = "GIBI_BYTE"

	// LogMetricConfigUnitGIGABYTE captures enum value "GIGA_BYTE"
	LogMetricConfigUnitGIGABYTE string = "GIGA_BYTE"

	// LogMetricConfigUnitHOUR captures enum value "HOUR"
	LogMetricConfigUnitHOUR string = "HOUR"

	// LogMetricConfigUnitKIBIBYTE captures enum value "KIBI_BYTE"
	LogMetricConfigUnitKIBIBYTE string = "KIBI_BYTE"

	// LogMetricConfigUnitKIBIBYTEPERHOUR captures enum value "KIBI_BYTE_PER_HOUR"
	LogMetricConfigUnitKIBIBYTEPERHOUR string = "KIBI_BYTE_PER_HOUR"

	// LogMetricConfigUnitKIBIBYTEPERMINUTE captures enum value "KIBI_BYTE_PER_MINUTE"
	LogMetricConfigUnitKIBIBYTEPERMINUTE string = "KIBI_BYTE_PER_MINUTE"

	// LogMetricConfigUnitKIBIBYTEPERSECOND captures enum value "KIBI_BYTE_PER_SECOND"
	LogMetricConfigUnitKIBIBYTEPERSECOND string = "KIBI_BYTE_PER_SECOND"

	// LogMetricConfigUnitKILOBYTE captures enum value "KILO_BYTE"
	LogMetricConfigUnitKILOBYTE string = "KILO_BYTE"

	// LogMetricConfigUnitKILOBYTEPERHOUR captures enum value "KILO_BYTE_PER_HOUR"
	LogMetricConfigUnitKILOBYTEPERHOUR string = "KILO_BYTE_PER_HOUR"

	// LogMetricConfigUnitKILOBYTEPERMINUTE captures enum value "KILO_BYTE_PER_MINUTE"
	LogMetricConfigUnitKILOBYTEPERMINUTE string = "KILO_BYTE_PER_MINUTE"

	// LogMetricConfigUnitKILOBYTEPERSECOND captures enum value "KILO_BYTE_PER_SECOND"
	LogMetricConfigUnitKILOBYTEPERSECOND string = "KILO_BYTE_PER_SECOND"

	// LogMetricConfigUnitMEBIBYTE captures enum value "MEBI_BYTE"
	LogMetricConfigUnitMEBIBYTE string = "MEBI_BYTE"

	// LogMetricConfigUnitMEBIBYTEPERHOUR captures enum value "MEBI_BYTE_PER_HOUR"
	LogMetricConfigUnitMEBIBYTEPERHOUR string = "MEBI_BYTE_PER_HOUR"

	// LogMetricConfigUnitMEBIBYTEPERMINUTE captures enum value "MEBI_BYTE_PER_MINUTE"
	LogMetricConfigUnitMEBIBYTEPERMINUTE string = "MEBI_BYTE_PER_MINUTE"

	// LogMetricConfigUnitMEBIBYTEPERSECOND captures enum value "MEBI_BYTE_PER_SECOND"
	LogMetricConfigUnitMEBIBYTEPERSECOND string = "MEBI_BYTE_PER_SECOND"

	// LogMetricConfigUnitMEGABYTE captures enum value "MEGA_BYTE"
	LogMetricConfigUnitMEGABYTE string = "MEGA_BYTE"

	// LogMetricConfigUnitMEGABYTEPERHOUR captures enum value "MEGA_BYTE_PER_HOUR"
	LogMetricConfigUnitMEGABYTEPERHOUR string = "MEGA_BYTE_PER_HOUR"

	// LogMetricConfigUnitMEGABYTEPERMINUTE captures enum value "MEGA_BYTE_PER_MINUTE"
	LogMetricConfigUnitMEGABYTEPERMINUTE string = "MEGA_BYTE_PER_MINUTE"

	// LogMetricConfigUnitMEGABYTEPERSECOND captures enum value "MEGA_BYTE_PER_SECOND"
	LogMetricConfigUnitMEGABYTEPERSECOND string = "MEGA_BYTE_PER_SECOND"

	// LogMetricConfigUnitMICROSECOND captures enum value "MICRO_SECOND"
	LogMetricConfigUnitMICROSECOND string = "MICRO_SECOND"

	// LogMetricConfigUnitMILLICORES captures enum value "MILLI_CORES"
	LogMetricConfigUnitMILLICORES string = "MILLI_CORES"

	// LogMetricConfigUnitMILLISECOND captures enum value "MILLI_SECOND"
	LogMetricConfigUnitMILLISECOND string = "MILLI_SECOND"

	// LogMetricConfigUnitMILLISECONDPERMINUTE captures enum value "MILLI_SECOND_PER_MINUTE"
	LogMetricConfigUnitMILLISECONDPERMINUTE string = "MILLI_SECOND_PER_MINUTE"

	// LogMetricConfigUnitMINUTE captures enum value "MINUTE"
	LogMetricConfigUnitMINUTE string = "MINUTE"

	// LogMetricConfigUnitNANOSECOND captures enum value "NANO_SECOND"
	LogMetricConfigUnitNANOSECOND string = "NANO_SECOND"

	// LogMetricConfigUnitNANOSECONDPERMINUTE captures enum value "NANO_SECOND_PER_MINUTE"
	LogMetricConfigUnitNANOSECONDPERMINUTE string = "NANO_SECOND_PER_MINUTE"

	// LogMetricConfigUnitNOTAPPLICABLE captures enum value "NOT_APPLICABLE"
	LogMetricConfigUnitNOTAPPLICABLE string = "NOT_APPLICABLE"

	// LogMetricConfigUnitPERCENT captures enum value "PERCENT"
	LogMetricConfigUnitPERCENT string = "PERCENT"

	// LogMetricConfigUnitPERHOUR captures enum value "PER_HOUR"
	LogMetricConfigUnitPERHOUR string = "PER_HOUR"

	// LogMetricConfigUnitPERMINUTE captures enum value "PER_MINUTE"
	LogMetricConfigUnitPERMINUTE string = "PER_MINUTE"

	// LogMetricConfigUnitPERSECOND captures enum value "PER_SECOND"
	LogMetricConfigUnitPERSECOND string = "PER_SECOND"

	// LogMetricConfigUnitPROMILLE captures enum value "PROMILLE"
	LogMetricConfigUnitPROMILLE string = "PROMILLE"

	// LogMetricConfigUnitRATIO captures enum value "RATIO"
	LogMetricConfigUnitRATIO string = "RATIO"

	// LogMetricConfigUnitSECOND captures enum value "SECOND"
	LogMetricConfigUnitSECOND string = "SECOND"

	// LogMetricConfigUnitSTATE captures enum value "STATE"
	LogMetricConfigUnitSTATE string = "STATE"

	// LogMetricConfigUnitUNSPECIFIED captures enum value "UNSPECIFIED"
	LogMetricConfigUnitUNSPECIFIED string = "UNSPECIFIED"
)

// prop value enum
func (m *LogMetricConfig) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, logMetricConfigTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LogMetricConfig) validateUnit(formats strfmt.Registry) error {

	if err := validate.Required("unit", "body", m.Unit); err != nil {
		return err
	}

	// value enum
	if err := m.validateUnitEnum("unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LogMetricConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogMetricConfig) UnmarshalBinary(b []byte) error {
	var res LogMetricConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
