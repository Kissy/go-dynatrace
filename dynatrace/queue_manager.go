// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// QueueManager Parameters of the queue manager.
// swagger:model QueueManager
type QueueManager struct {

	// The list of alias queues in the queue manager.
	// Required: true
	// Max Items: 10000
	// Min Items: 0
	AliasQueues []*AliasQueue `json:"aliasQueues"`

	// The list of cluster queues in the queue manager.
	// Required: true
	// Max Items: 10000
	// Min Items: 0
	ClusterQueues []*ClusterQueue `json:"clusterQueues"`

	// The queue manager will have access to all cluster visible queues in these [clusters](https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q002750_.htm).
	// Required: true
	// Max Items: 10000
	// Min Items: 0
	Clusters []string `json:"clusters"`

	// The name of the queue manager.
	// Required: true
	// Max Length: 500
	// Min Length: 1
	Name *string `json:"name"`

	// The list of remote queues in the queue manager.
	// Required: true
	// Max Items: 10000
	// Min Items: 0
	RemoteQueues []*RemoteQueue `json:"remoteQueues"`
}

// Validate validates this queue manager
func (m *QueueManager) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAliasQueues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterQueues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteQueues(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QueueManager) validateAliasQueues(formats strfmt.Registry) error {

	if err := validate.Required("aliasQueues", "body", m.AliasQueues); err != nil {
		return err
	}

	iAliasQueuesSize := int64(len(m.AliasQueues))

	if err := validate.MinItems("aliasQueues", "body", iAliasQueuesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("aliasQueues", "body", iAliasQueuesSize, 10000); err != nil {
		return err
	}

	for i := 0; i < len(m.AliasQueues); i++ {
		if swag.IsZero(m.AliasQueues[i]) { // not required
			continue
		}

		if m.AliasQueues[i] != nil {
			if err := m.AliasQueues[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aliasQueues" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *QueueManager) validateClusterQueues(formats strfmt.Registry) error {

	if err := validate.Required("clusterQueues", "body", m.ClusterQueues); err != nil {
		return err
	}

	iClusterQueuesSize := int64(len(m.ClusterQueues))

	if err := validate.MinItems("clusterQueues", "body", iClusterQueuesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("clusterQueues", "body", iClusterQueuesSize, 10000); err != nil {
		return err
	}

	for i := 0; i < len(m.ClusterQueues); i++ {
		if swag.IsZero(m.ClusterQueues[i]) { // not required
			continue
		}

		if m.ClusterQueues[i] != nil {
			if err := m.ClusterQueues[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusterQueues" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *QueueManager) validateClusters(formats strfmt.Registry) error {

	if err := validate.Required("clusters", "body", m.Clusters); err != nil {
		return err
	}

	iClustersSize := int64(len(m.Clusters))

	if err := validate.MinItems("clusters", "body", iClustersSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("clusters", "body", iClustersSize, 10000); err != nil {
		return err
	}

	return nil
}

func (m *QueueManager) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", string(*m.Name), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 500); err != nil {
		return err
	}

	return nil
}

func (m *QueueManager) validateRemoteQueues(formats strfmt.Registry) error {

	if err := validate.Required("remoteQueues", "body", m.RemoteQueues); err != nil {
		return err
	}

	iRemoteQueuesSize := int64(len(m.RemoteQueues))

	if err := validate.MinItems("remoteQueues", "body", iRemoteQueuesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("remoteQueues", "body", iRemoteQueuesSize, 10000); err != nil {
		return err
	}

	for i := 0; i < len(m.RemoteQueues); i++ {
		if swag.IsZero(m.RemoteQueues[i]) { // not required
			continue
		}

		if m.RemoteQueues[i] != nil {
			if err := m.RemoteQueues[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("remoteQueues" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *QueueManager) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QueueManager) UnmarshalBinary(b []byte) error {
	var res QueueManager
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
