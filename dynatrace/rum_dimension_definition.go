// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RumDimensionDefinition rum dimension definition
// swagger:model RumDimensionDefinition
type RumDimensionDefinition struct {

	// The dimension of this metric.
	// Required: true
	// Enum: [Browser ErrorContext ErrorOrigin ErrorType GeoLocation StringProperty UserActionType]
	Dimension *string `json:"dimension"`

	// The key of the user action property. Only required if dimension is set to "StringProperty"
	PropertyKey string `json:"propertyKey,omitempty"`

	// The number of top values to be calculated.
	// Required: true
	// Maximum: 200
	// Minimum: 1
	TopX *int32 `json:"topX"`
}

// Validate validates this rum dimension definition
func (m *RumDimensionDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDimension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTopX(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var rumDimensionDefinitionTypeDimensionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Browser","ErrorContext","ErrorOrigin","ErrorType","GeoLocation","StringProperty","UserActionType"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		rumDimensionDefinitionTypeDimensionPropEnum = append(rumDimensionDefinitionTypeDimensionPropEnum, v)
	}
}

const (

	// RumDimensionDefinitionDimensionBrowser captures enum value "Browser"
	RumDimensionDefinitionDimensionBrowser string = "Browser"

	// RumDimensionDefinitionDimensionErrorContext captures enum value "ErrorContext"
	RumDimensionDefinitionDimensionErrorContext string = "ErrorContext"

	// RumDimensionDefinitionDimensionErrorOrigin captures enum value "ErrorOrigin"
	RumDimensionDefinitionDimensionErrorOrigin string = "ErrorOrigin"

	// RumDimensionDefinitionDimensionErrorType captures enum value "ErrorType"
	RumDimensionDefinitionDimensionErrorType string = "ErrorType"

	// RumDimensionDefinitionDimensionGeoLocation captures enum value "GeoLocation"
	RumDimensionDefinitionDimensionGeoLocation string = "GeoLocation"

	// RumDimensionDefinitionDimensionStringProperty captures enum value "StringProperty"
	RumDimensionDefinitionDimensionStringProperty string = "StringProperty"

	// RumDimensionDefinitionDimensionUserActionType captures enum value "UserActionType"
	RumDimensionDefinitionDimensionUserActionType string = "UserActionType"
)

// prop value enum
func (m *RumDimensionDefinition) validateDimensionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, rumDimensionDefinitionTypeDimensionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RumDimensionDefinition) validateDimension(formats strfmt.Registry) error {

	if err := validate.Required("dimension", "body", m.Dimension); err != nil {
		return err
	}

	// value enum
	if err := m.validateDimensionEnum("dimension", "body", *m.Dimension); err != nil {
		return err
	}

	return nil
}

func (m *RumDimensionDefinition) validateTopX(formats strfmt.Registry) error {

	if err := validate.Required("topX", "body", m.TopX); err != nil {
		return err
	}

	if err := validate.MinimumInt("topX", "body", int64(*m.TopX), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("topX", "body", int64(*m.TopX), 200, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RumDimensionDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RumDimensionDefinition) UnmarshalBinary(b []byte) error {
	var res RumDimensionDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
