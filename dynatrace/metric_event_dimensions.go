// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// MetricEventDimensions A single filter for the metrics dimensions.
//
// This is the base version of the filter, depending on the type,
// the actual JSON may contain additional fields.
// swagger:discriminator MetricEventDimensions filterType
type MetricEventDimensions interface {
	runtime.Validatable

	// Defines the actual set of fields depending on the value:
	//
	// ENTITY -> MetricEventEntityDimensions
	// STRING -> MetricEventStringDimensions
	//
	// Required: true
	// Enum: [ENTITY STRING]
	FilterType() string
	SetFilterType(string)

	// The dimensions index on the metric.
	// Required: true
	Index() *int32
	SetIndex(*int32)

	// The dimensions name. Sending this has no effect while creating a configuration, as only the *index* of the dimension is used here -> dimension names might change, indexes not.
	Name() string
	SetName(string)
}

type metricEventDimensions struct {
	filterTypeField string

	indexField *int32

	nameField string
}

// FilterType gets the filter type of this polymorphic type
func (m *metricEventDimensions) FilterType() string {
	return "MetricEventDimensions"
}

// SetFilterType sets the filter type of this polymorphic type
func (m *metricEventDimensions) SetFilterType(val string) {

}

// Index gets the index of this polymorphic type
func (m *metricEventDimensions) Index() *int32 {
	return m.indexField
}

// SetIndex sets the index of this polymorphic type
func (m *metricEventDimensions) SetIndex(val *int32) {
	m.indexField = val
}

// Name gets the name of this polymorphic type
func (m *metricEventDimensions) Name() string {
	return m.nameField
}

// SetName sets the name of this polymorphic type
func (m *metricEventDimensions) SetName(val string) {
	m.nameField = val
}

// UnmarshalMetricEventDimensionsSlice unmarshals polymorphic slices of MetricEventDimensions
func UnmarshalMetricEventDimensionsSlice(reader io.Reader, consumer runtime.Consumer) ([]MetricEventDimensions, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []MetricEventDimensions
	for _, element := range elements {
		obj, err := unmarshalMetricEventDimensions(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalMetricEventDimensions unmarshals polymorphic MetricEventDimensions
func UnmarshalMetricEventDimensions(reader io.Reader, consumer runtime.Consumer) (MetricEventDimensions, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalMetricEventDimensions(data, consumer)
}

func unmarshalMetricEventDimensions(data []byte, consumer runtime.Consumer) (MetricEventDimensions, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the filterType property.
	var getType struct {
		FilterType string `json:"filterType"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("filterType", "body", getType.FilterType); err != nil {
		return nil, err
	}

	// The value of filterType is used to determine which type to create and unmarshal the data into
	switch getType.FilterType {
	case "MetricEventDimensions":
		var result metricEventDimensions
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "MetricEventEntityDimensions":
		var result MetricEventEntityDimensions
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "MetricEventStringDimensions":
		var result MetricEventStringDimensions
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid filterType value: %q", getType.FilterType)

}

// Validate validates this metric event dimensions
func (m *metricEventDimensions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIndex(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var metricEventDimensionsTypeFilterTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ENTITY","STRING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metricEventDimensionsTypeFilterTypePropEnum = append(metricEventDimensionsTypeFilterTypePropEnum, v)
	}
}

const (

	// MetricEventDimensionsFilterTypeENTITY captures enum value "ENTITY"
	MetricEventDimensionsFilterTypeENTITY string = "ENTITY"

	// MetricEventDimensionsFilterTypeSTRING captures enum value "STRING"
	MetricEventDimensionsFilterTypeSTRING string = "STRING"
)

// prop value enum
func (m *metricEventDimensions) validateFilterTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, metricEventDimensionsTypeFilterTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *metricEventDimensions) validateIndex(formats strfmt.Registry) error {

	if err := validate.Required("index", "body", m.Index()); err != nil {
		return err
	}

	return nil
}
