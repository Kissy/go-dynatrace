// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NotificationConfig Configuration of a notification. The actual set of fields depends on the `type` of the notification.
// See the [Notifications API - JSON models](https://www.dynatrace.com/support/help/shortlink/api-config-notifications-models) help topic for example models of every notification type.
// swagger:discriminator NotificationConfig type
type NotificationConfig interface {
	runtime.Validatable

	// The configuration is enabled (`true`) or disabled (`false`).
	// Required: true
	Active() *bool
	SetActive(*bool)

	// The ID of the associated alerting profile.
	// Required: true
	// Format: uuid
	AlertingProfile() *strfmt.UUID
	SetAlertingProfile(*strfmt.UUID)

	// The ID of the notification configuration.
	// Format: uuid
	ID() strfmt.UUID
	SetID(strfmt.UUID)

	// The name of the notification configuration.
	// Required: true
	// Max Length: 100
	// Min Length: 1
	Name() *string
	SetName(*string)

	// Defines the actual set of fields depending on the value:
	//
	// EMAIL -> EmailNotificationConfig
	// PAGER_DUTY -> PagerDutyNotificationConfig
	// WEBHOOK -> WebHookNotificationConfig
	// SLACK -> SlackNotificationConfig
	// HIPCHAT -> HipChatNotificationConfig
	// VICTOROPS -> VictorOpsNotificationConfig
	// SERVICE_NOW -> ServiceNowNotificationConfig
	// XMATTERS -> XMattersNotificationConfig
	// ANSIBLETOWER -> AnsibleTowerNotificationConfig
	// OPS_GENIE -> OpsGenieNotificationConfig
	// JIRA -> JiraNotificationConfig
	// TRELLO -> TrelloNotificationConfig
	//
	// Required: true
	// Enum: [EMAIL PAGER_DUTY WEBHOOK SLACK HIPCHAT VICTOROPS SERVICE_NOW XMATTERS ANSIBLETOWER OPS_GENIE JIRA TRELLO]
	Type() string
	SetType(string)
}

type notificationConfig struct {
	activeField *bool

	alertingProfileField *strfmt.UUID

	idField strfmt.UUID

	nameField *string

	typeField string
}

// Active gets the active of this polymorphic type
func (m *notificationConfig) Active() *bool {
	return m.activeField
}

// SetActive sets the active of this polymorphic type
func (m *notificationConfig) SetActive(val *bool) {
	m.activeField = val
}

// AlertingProfile gets the alerting profile of this polymorphic type
func (m *notificationConfig) AlertingProfile() *strfmt.UUID {
	return m.alertingProfileField
}

// SetAlertingProfile sets the alerting profile of this polymorphic type
func (m *notificationConfig) SetAlertingProfile(val *strfmt.UUID) {
	m.alertingProfileField = val
}

// ID gets the id of this polymorphic type
func (m *notificationConfig) ID() strfmt.UUID {
	return m.idField
}

// SetID sets the id of this polymorphic type
func (m *notificationConfig) SetID(val strfmt.UUID) {
	m.idField = val
}

// Name gets the name of this polymorphic type
func (m *notificationConfig) Name() *string {
	return m.nameField
}

// SetName sets the name of this polymorphic type
func (m *notificationConfig) SetName(val *string) {
	m.nameField = val
}

// Type gets the type of this polymorphic type
func (m *notificationConfig) Type() string {
	return "NotificationConfig"
}

// SetType sets the type of this polymorphic type
func (m *notificationConfig) SetType(val string) {

}

// UnmarshalNotificationConfigSlice unmarshals polymorphic slices of NotificationConfig
func UnmarshalNotificationConfigSlice(reader io.Reader, consumer runtime.Consumer) ([]NotificationConfig, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []NotificationConfig
	for _, element := range elements {
		obj, err := unmarshalNotificationConfig(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalNotificationConfig unmarshals polymorphic NotificationConfig
func UnmarshalNotificationConfig(reader io.Reader, consumer runtime.Consumer) (NotificationConfig, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalNotificationConfig(data, consumer)
}

func unmarshalNotificationConfig(data []byte, consumer runtime.Consumer) (NotificationConfig, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the type property.
	var getType struct {
		Type string `json:"type"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("type", "body", getType.Type); err != nil {
		return nil, err
	}

	// The value of type is used to determine which type to create and unmarshal the data into
	switch getType.Type {
	case "AnsibleTowerNotificationConfig":
		var result AnsibleTowerNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "EmailNotificationConfig":
		var result EmailNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "HipChatNotificationConfig":
		var result HipChatNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "JiraNotificationConfig":
		var result JiraNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "NotificationConfig":
		var result notificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "OpsGenieNotificationConfig":
		var result OpsGenieNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "PagerDutyNotificationConfig":
		var result PagerDutyNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ServiceNowNotificationConfig":
		var result ServiceNowNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "SlackNotificationConfig":
		var result SlackNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TrelloNotificationConfig":
		var result TrelloNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "VictorOpsNotificationConfig":
		var result VictorOpsNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "WebHookNotificationConfig":
		var result WebHookNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "XMattersNotificationConfig":
		var result XMattersNotificationConfig
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid type value: %q", getType.Type)

}

// Validate validates this notification config
func (m *notificationConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActive(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertingProfile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *notificationConfig) validateActive(formats strfmt.Registry) error {

	if err := validate.Required("active", "body", m.Active()); err != nil {
		return err
	}

	return nil
}

func (m *notificationConfig) validateAlertingProfile(formats strfmt.Registry) error {

	if err := validate.Required("alertingProfile", "body", m.AlertingProfile()); err != nil {
		return err
	}

	if err := validate.FormatOf("alertingProfile", "body", "uuid", m.AlertingProfile().String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *notificationConfig) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID()) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID().String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *notificationConfig) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name()); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", string(*m.Name()), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name()), 100); err != nil {
		return err
	}

	return nil
}

var notificationConfigTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EMAIL","PAGER_DUTY","WEBHOOK","SLACK","HIPCHAT","VICTOROPS","SERVICE_NOW","XMATTERS","ANSIBLETOWER","OPS_GENIE","JIRA","TRELLO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		notificationConfigTypeTypePropEnum = append(notificationConfigTypeTypePropEnum, v)
	}
}

const (

	// NotificationConfigTypeEMAIL captures enum value "EMAIL"
	NotificationConfigTypeEMAIL string = "EMAIL"

	// NotificationConfigTypePAGERDUTY captures enum value "PAGER_DUTY"
	NotificationConfigTypePAGERDUTY string = "PAGER_DUTY"

	// NotificationConfigTypeWEBHOOK captures enum value "WEBHOOK"
	NotificationConfigTypeWEBHOOK string = "WEBHOOK"

	// NotificationConfigTypeSLACK captures enum value "SLACK"
	NotificationConfigTypeSLACK string = "SLACK"

	// NotificationConfigTypeHIPCHAT captures enum value "HIPCHAT"
	NotificationConfigTypeHIPCHAT string = "HIPCHAT"

	// NotificationConfigTypeVICTOROPS captures enum value "VICTOROPS"
	NotificationConfigTypeVICTOROPS string = "VICTOROPS"

	// NotificationConfigTypeSERVICENOW captures enum value "SERVICE_NOW"
	NotificationConfigTypeSERVICENOW string = "SERVICE_NOW"

	// NotificationConfigTypeXMATTERS captures enum value "XMATTERS"
	NotificationConfigTypeXMATTERS string = "XMATTERS"

	// NotificationConfigTypeANSIBLETOWER captures enum value "ANSIBLETOWER"
	NotificationConfigTypeANSIBLETOWER string = "ANSIBLETOWER"

	// NotificationConfigTypeOPSGENIE captures enum value "OPS_GENIE"
	NotificationConfigTypeOPSGENIE string = "OPS_GENIE"

	// NotificationConfigTypeJIRA captures enum value "JIRA"
	NotificationConfigTypeJIRA string = "JIRA"

	// NotificationConfigTypeTRELLO captures enum value "TRELLO"
	NotificationConfigTypeTRELLO string = "TRELLO"
)

// prop value enum
func (m *notificationConfig) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, notificationConfigTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}
