// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MethodReference Configuration of a method to be captured.
// swagger:model MethodReference
type MethodReference struct {

	// The list of argument types.
	// Required: true
	ArgumentTypes []string `json:"argumentTypes"`

	// The class name where the method to capture resides.
	//
	//  Either this or the **fileName** must be set.
	ClassName string `json:"className,omitempty"`

	// The file name where the method to capture resides.
	//
	//  Either this or **className** must be set.
	FileName string `json:"fileName,omitempty"`

	// The operator of the comparison.
	//
	//  If not set, `EQUALS` is used.
	// Enum: [ENDS_WITH EQUALS STARTS_WITH]
	FileNameMatcher string `json:"fileNameMatcher,omitempty"`

	// The name of the method to capture.
	// Required: true
	MethodName *string `json:"methodName"`

	// The modifiers of the method to capture.
	// Required: true
	// Unique: true
	Modifiers []string `json:"modifiers"`

	// The return type.
	// Required: true
	ReturnType *string `json:"returnType"`

	// The visibility of the method to capture.
	// Required: true
	// Enum: [INTERNAL PACKAGE_PROTECTED PRIVATE PROTECTED PUBLIC]
	Visibility *string `json:"visibility"`
}

// Validate validates this method reference
func (m *MethodReference) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArgumentTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileNameMatcher(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethodName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReturnType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MethodReference) validateArgumentTypes(formats strfmt.Registry) error {

	if err := validate.Required("argumentTypes", "body", m.ArgumentTypes); err != nil {
		return err
	}

	return nil
}

var methodReferenceTypeFileNameMatcherPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ENDS_WITH","EQUALS","STARTS_WITH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		methodReferenceTypeFileNameMatcherPropEnum = append(methodReferenceTypeFileNameMatcherPropEnum, v)
	}
}

const (

	// MethodReferenceFileNameMatcherENDSWITH captures enum value "ENDS_WITH"
	MethodReferenceFileNameMatcherENDSWITH string = "ENDS_WITH"

	// MethodReferenceFileNameMatcherEQUALS captures enum value "EQUALS"
	MethodReferenceFileNameMatcherEQUALS string = "EQUALS"

	// MethodReferenceFileNameMatcherSTARTSWITH captures enum value "STARTS_WITH"
	MethodReferenceFileNameMatcherSTARTSWITH string = "STARTS_WITH"
)

// prop value enum
func (m *MethodReference) validateFileNameMatcherEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, methodReferenceTypeFileNameMatcherPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MethodReference) validateFileNameMatcher(formats strfmt.Registry) error {

	if swag.IsZero(m.FileNameMatcher) { // not required
		return nil
	}

	// value enum
	if err := m.validateFileNameMatcherEnum("fileNameMatcher", "body", m.FileNameMatcher); err != nil {
		return err
	}

	return nil
}

func (m *MethodReference) validateMethodName(formats strfmt.Registry) error {

	if err := validate.Required("methodName", "body", m.MethodName); err != nil {
		return err
	}

	return nil
}

var methodReferenceModifiersItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ABSTRACT","EXTERN","FINAL","NATIVE","STATIC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		methodReferenceModifiersItemsEnum = append(methodReferenceModifiersItemsEnum, v)
	}
}

func (m *MethodReference) validateModifiersItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, methodReferenceModifiersItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *MethodReference) validateModifiers(formats strfmt.Registry) error {

	if err := validate.Required("modifiers", "body", m.Modifiers); err != nil {
		return err
	}

	if err := validate.UniqueItems("modifiers", "body", m.Modifiers); err != nil {
		return err
	}

	for i := 0; i < len(m.Modifiers); i++ {

		// value enum
		if err := m.validateModifiersItemsEnum("modifiers"+"."+strconv.Itoa(i), "body", m.Modifiers[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *MethodReference) validateReturnType(formats strfmt.Registry) error {

	if err := validate.Required("returnType", "body", m.ReturnType); err != nil {
		return err
	}

	return nil
}

var methodReferenceTypeVisibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INTERNAL","PACKAGE_PROTECTED","PRIVATE","PROTECTED","PUBLIC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		methodReferenceTypeVisibilityPropEnum = append(methodReferenceTypeVisibilityPropEnum, v)
	}
}

const (

	// MethodReferenceVisibilityINTERNAL captures enum value "INTERNAL"
	MethodReferenceVisibilityINTERNAL string = "INTERNAL"

	// MethodReferenceVisibilityPACKAGEPROTECTED captures enum value "PACKAGE_PROTECTED"
	MethodReferenceVisibilityPACKAGEPROTECTED string = "PACKAGE_PROTECTED"

	// MethodReferenceVisibilityPRIVATE captures enum value "PRIVATE"
	MethodReferenceVisibilityPRIVATE string = "PRIVATE"

	// MethodReferenceVisibilityPROTECTED captures enum value "PROTECTED"
	MethodReferenceVisibilityPROTECTED string = "PROTECTED"

	// MethodReferenceVisibilityPUBLIC captures enum value "PUBLIC"
	MethodReferenceVisibilityPUBLIC string = "PUBLIC"
)

// prop value enum
func (m *MethodReference) validateVisibilityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, methodReferenceTypeVisibilityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MethodReference) validateVisibility(formats strfmt.Registry) error {

	if err := validate.Required("visibility", "body", m.Visibility); err != nil {
		return err
	}

	// value enum
	if err := m.validateVisibilityEnum("visibility", "body", *m.Visibility); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MethodReference) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MethodReference) UnmarshalBinary(b []byte) error {
	var res MethodReference
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
