// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CapturedMethod captured method
// swagger:model CapturedMethod
type CapturedMethod struct {

	// The index of the argument to capture. Set `0` to capture the return value, `1` or higher to capture a mehtod argument.
	//
	//  Required if the **capture** is set to `ARGUMENT`.
	//
	//  Not applicable in other cases.
	// Minimum: 0
	ArgumentIndex *int32 `json:"argumentIndex,omitempty"`

	// What to capture from the method.
	// Required: true
	// Enum: [ARGUMENT CLASS_NAME METHOD_NAME OCCURRENCES SIMPLE_CLASS_NAME THIS]
	Capture *string `json:"capture"`

	// The getter chain to apply to the captured object. It is required in one of the following cases:
	//
	//  The **capture** is set to `THIS`.
	//   The **capture** is set to `ARGUMENT`, and the argument is not a primitive, a primitive wrapper class, a string, or an array.
	//
	//  Not applicable in other cases.
	DeepObjectAccess string `json:"deepObjectAccess,omitempty"`

	// The method where data is captured.
	// Required: true
	Method *MethodReference `json:"method"`
}

// Validate validates this captured method
func (m *CapturedMethod) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArgumentIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CapturedMethod) validateArgumentIndex(formats strfmt.Registry) error {

	if swag.IsZero(m.ArgumentIndex) { // not required
		return nil
	}

	if err := validate.MinimumInt("argumentIndex", "body", int64(*m.ArgumentIndex), 0, false); err != nil {
		return err
	}

	return nil
}

var capturedMethodTypeCapturePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ARGUMENT","CLASS_NAME","METHOD_NAME","OCCURRENCES","SIMPLE_CLASS_NAME","THIS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		capturedMethodTypeCapturePropEnum = append(capturedMethodTypeCapturePropEnum, v)
	}
}

const (

	// CapturedMethodCaptureARGUMENT captures enum value "ARGUMENT"
	CapturedMethodCaptureARGUMENT string = "ARGUMENT"

	// CapturedMethodCaptureCLASSNAME captures enum value "CLASS_NAME"
	CapturedMethodCaptureCLASSNAME string = "CLASS_NAME"

	// CapturedMethodCaptureMETHODNAME captures enum value "METHOD_NAME"
	CapturedMethodCaptureMETHODNAME string = "METHOD_NAME"

	// CapturedMethodCaptureOCCURRENCES captures enum value "OCCURRENCES"
	CapturedMethodCaptureOCCURRENCES string = "OCCURRENCES"

	// CapturedMethodCaptureSIMPLECLASSNAME captures enum value "SIMPLE_CLASS_NAME"
	CapturedMethodCaptureSIMPLECLASSNAME string = "SIMPLE_CLASS_NAME"

	// CapturedMethodCaptureTHIS captures enum value "THIS"
	CapturedMethodCaptureTHIS string = "THIS"
)

// prop value enum
func (m *CapturedMethod) validateCaptureEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, capturedMethodTypeCapturePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CapturedMethod) validateCapture(formats strfmt.Registry) error {

	if err := validate.Required("capture", "body", m.Capture); err != nil {
		return err
	}

	// value enum
	if err := m.validateCaptureEnum("capture", "body", *m.Capture); err != nil {
		return err
	}

	return nil
}

func (m *CapturedMethod) validateMethod(formats strfmt.Registry) error {

	if err := validate.Required("method", "body", m.Method); err != nil {
		return err
	}

	if m.Method != nil {
		if err := m.Method.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("method")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CapturedMethod) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CapturedMethod) UnmarshalBinary(b []byte) error {
	var res CapturedMethod
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
