// Code generated by go-swagger; DO NOT EDIT.

package dynatrace

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// TransformationBase Configuration of transformation of the detected value.
//
// If several transformations are specified, they are handled sequentially from top to bottom. Each transformation is applied to the result of the preceding transformation. For example, the second transformation is applied to the result of the first transformation.
//
// The actual set of fields depends on the `type` of the transformation.
// swagger:discriminator TransformationBase type
type TransformationBase interface {
	runtime.Validatable

	// Defines the actual set of fields depending on the value:
	//
	// BEFORE -> BeforeTransformation
	// AFTER -> AfterTransformation
	// BETWEEN -> BetweenTransformation
	// REPLACE_BETWEEN -> ReplaceBetweenTransformation
	// REMOVE_NUMBERS -> RemoveNumbersTransformation
	// REMOVE_CREDIT_CARDS -> RemoveCreditCardNumbersTransformation
	// REMOVE_IBANS -> RemoveIBANsTransformation
	// REMOVE_IPS -> RemoveIPsTransformation
	// SPLIT_SELECT -> SplitSelectTransformation
	// TAKE_SEGMENTS -> TakeSegmentsTransformation
	//
	// Required: true
	// Enum: [BEFORE AFTER BETWEEN REPLACE_BETWEEN REMOVE_NUMBERS REMOVE_CREDIT_CARDS REMOVE_IBANS REMOVE_IPS SPLIT_SELECT TAKE_SEGMENTS]
	Type() string
	SetType(string)
}

type transformationBase struct {
	typeField string
}

// Type gets the type of this polymorphic type
func (m *transformationBase) Type() string {
	return "TransformationBase"
}

// SetType sets the type of this polymorphic type
func (m *transformationBase) SetType(val string) {

}

// UnmarshalTransformationBaseSlice unmarshals polymorphic slices of TransformationBase
func UnmarshalTransformationBaseSlice(reader io.Reader, consumer runtime.Consumer) ([]TransformationBase, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []TransformationBase
	for _, element := range elements {
		obj, err := unmarshalTransformationBase(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalTransformationBase unmarshals polymorphic TransformationBase
func UnmarshalTransformationBase(reader io.Reader, consumer runtime.Consumer) (TransformationBase, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalTransformationBase(data, consumer)
}

func unmarshalTransformationBase(data []byte, consumer runtime.Consumer) (TransformationBase, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the type property.
	var getType struct {
		Type string `json:"type"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("type", "body", getType.Type); err != nil {
		return nil, err
	}

	// The value of type is used to determine which type to create and unmarshal the data into
	switch getType.Type {
	case "AfterTransformation":
		var result AfterTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "BeforeTransformation":
		var result BeforeTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "BetweenTransformation":
		var result BetweenTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "RemoveCreditCardNumbersTransformation":
		var result RemoveCreditCardNumbersTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "RemoveIBANsTransformation":
		var result RemoveIBANsTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "RemoveIPsTransformation":
		var result RemoveIPsTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "RemoveNumbersTransformation":
		var result RemoveNumbersTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ReplaceBetweenTransformation":
		var result ReplaceBetweenTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "SplitSelectTransformation":
		var result SplitSelectTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TakeSegmentsTransformation":
		var result TakeSegmentsTransformation
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TransformationBase":
		var result transformationBase
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid type value: %q", getType.Type)

}

// Validate validates this transformation base
func (m *transformationBase) Validate(formats strfmt.Registry) error {
	return nil
}
